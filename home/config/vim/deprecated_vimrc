"
" Deprecated Vim Plugins
"

" let g:isNeoBundleInstalled = 1
" let g:NeoBundleReadMe = expand(g:vimPath . '/bundle/neobundle.vim/README.md')
" if (!filereadable(g:NeoBundleReadMe))
"     echo 'Installing NeoBundle...'
"     echo ''
"     silent !mkdir -p ~/.vim/bundle
"     silent !git clone https://github.com/Shougo/neobundle.vim ~/.vim/bundle/neobundle.vim
"     let g:isNeoBundleInstalled = 0
" endif
"
" if has('vim_starting')
"     if &compatible
"         set nocompatible               " Be iMproved
"     endif
"
"     " Required:
"     set runtimepath+=~/.vim/bundle/neobundle.vim/
" endif
"
" " Required:
" call neobundle#begin(expand('~/.vim/bundle/'))
"
" " Let NeoBundle manage NeoBundle
" " Required:
" NeoBundleFetch 'Shougo/neobundle.vim'
"
" " My Bundles here:
" " Refer to |:NeoBundle-examples|.
" " Note: You don't set neobundle setting in .gvimrc!
"
" Plug 'vim-syntastic/syntastic', {
"             \ 'on' : 'SyntasticCheck' }
" Plug 'jistr/vim-nerdtree-tabs'
" " delimitMate has to be place before vim-endwise
" Plug 'tpope/vim-abolish', {
"             \ 'on_map' : [ [ 'n', 'cr' ] ] }
" Plug 'terryma/vim-expand-region'
" " BEGIN: xolox/vim-shell
" Plug 'xolox/vim-shell', {
"             \ 'on' : [ 'Maximize', 'Fullscreen', 'Open', 'MakeWithShell',
"             \          'LMakeWithShell' ] }
" Plug 'xolox/vim-misc'
" " END: xolox/vim-shell
" Plug 'Shougo/neoyank.vim'
" Plug 'Shougo/unite-session'
" Plug 'osyo-manga/vim-hopping'
" Plug 'vasconcelloslf/vim-foldfocus', {
"             \ 'on_func' : 'FoldFocus' }
" Plug 'tommcdo/vim-exchange', {
"             \ 'on_map' : [ [ 'n', 'cx' ], [ 'x', 'X' ] ] }
" Plug 'AndrewRadev/id3.vim', {
"             \ 'for' : 'mp3' }
" Plug 'PeterRincker/vim-argumentative'

" Plug 'chrisbra/NrrwRgn', {
"             \ 'on' : [ 'NR', 'NRV', 'NRL', 'WidenRegion' ] }
" No lazy-loading for chrisbra/changesPlugin. It needs to be enabled by default
" Plug 'chrisbra/changesPlugin'
" Plug 'tyru/current-func-info.vim'
" Plug 'mopp/mulfiles.vim'
" Plug 'uptech/vim-ping-cursor', {
"             \ 'on' : 'PingCursor' }
" Plug 'itchyny/vim-cursorword'
" Plug 'vim-utils/vim-vertical-move', {
" Plug 'janko-m/vim-test', {
"             \ 'on' : [
"             \     'TestNearest', 'TestFile', 'TestSuite', 'TestLast',
"             \     'TestVisit' ] }
" Plug 'junegunn/vim-github-dashboard', {
"             \ 'on' : [ 'GHActivity', GHDashboard' ] }
" Plug 'junegunn/limelight.vim', {
"             \ 'on' : [ 'Limelight' ] }
" Plug 'junegunn/fzf', {
"             \ 'do' : g:vimPath . '/bundle/fzf/install --no-key-bindings --no-completion' }
" Plug 'junegunn/fzf.vim' , {
"             \ 'on' : [ 'FzfFiles', 'FzfLines', 'FzfBLines' ] }
" Plug 'pbogut/fzf-mru.vim'
" Plug 'KabbAmine/lazyList.vim', {
"             \ 'on' : 'LazyList' }
" Plug 'henrik/vim-indexed-search'
" Plug 'danro/rename.vim', {
"             \ 'on' : 'Rename' }
" Plug 'kana/vim-grex', {
"             \ 'on' : [ 'Grey', 'Gred' ] }
" Plug 'embear/vim-foldsearch', {
"             \ 'on' : [ 'Fw', 'Fs', 'Fp', 'FS', 'Fl', 'Fc', 'Fi', 'Fd', 'Fe' ] }
" Plug 'kien/tabman.vim', {
"             \ 'on' : [ 'TMToggle', 'TMFocus' ] }
" Plug 'yegappan/scratch', {
"             \ 'on' : [ 'Sscratch', 'Scratch' ] }
" Plug 'benmills/vimux', {
"             \ 'on' : 'Vimux' }
" Plug 'mhinz/vim-startify', {
"             \ 'on' : 'Startify' }
" Plug 'mhinz/vim-grepper', {
"             \ 'on' : 'Grepper' }
" Plug 'salsifis/vim-transpose', {
"             \ 'on' : [ 'Transpose', 'TransposeWords', 'TransposeTab',
"             \              'TransposeCSV', 'TransposeInteractive' ] }
" No lazy-loading for gorkunov/smartpairs.vim.
" It must be started by default
" Plug 'gorkunov/smartpairs.vim'
" No lazy-loading for jszakmeister/vim-togglecursor.
" It must be started by default
" Plug 'jszakmeister/vim-togglecursor'
" Plug 'embear/vim-localvimrc', {
"             \ 'on' : [ 'LocalVimRC', 'LocalVimRCClear' ] }
" Plug 'Floobits/floobits-vim'
" Plug 'gregsexton/gitv', {
"             \ 'on_cmd' : 'Gitv',
"             \ 'depends' : 'vim-fugitive' }
" Plug 'osyo-manga/vim-marching', {
"             \ 'for' : [ 'c', 'cpp' ] }
" Plug 'davidhalter/jedi-vim', {
"             \ 'for' : [ 'python', 'vim' ] }
" Plug 'marijnh/tern_for_vim', {
"             \ 'for' : 'javascript' }
" " Conflicts with YankRing <leader>p
" Plug 'stephpy/vim-php-cs-fixer', {
"             \ 'for' : 'php' }
" Crucial: Copy the 'php.vim' file of https://github.com/StanAngeloff/php.vim to
"          under g:vimPath . '/syntax' for better PHP Experience in Vim
"          Drupal 7 Snippets: https://github.com/tanarurkerem/drupal-snippets
"          Drupal Syntax Checking: http://technosophos.com/2012/01/10/syntax-checking-drupal-vim-0.html
"          PHP & Drupal Coding Standard: http://www.echoditto.com/blog/getting-ahead-drupals-coding-standards-w-drupal-code-sniffer-vim-and-little-regex
"
" Plug 'm2mdas/phpcomplete-extended'          " (Required) For PHP
" Plug 'm2mdas/phpcomplete-extended-symfony'  " (Required) For Symfony2
"
" (Required) For Drupal
" Plug 'git://drupalcode.org/project/vimrc.git', {'rtp': 'bundle/vim-plugin-for-drupal/'}
"
" Plug 'tobyS/vmustache'                      " (Required) For PHP
" Plug 'docteurklein/vim-symfony'             " (Optional) For Symfony2
" Plug 'evidens/vim-twig'                     " (Required) For Symfony2
" Plug 'Valloric/YouCompleteMe'
" Plug 'tyru/autochmodx.vim'
" if has('win32') || has('win64')
"     Plug 'vim-airline/vim-airline'
" endif
" " Plugins (conflicting)
" Plug 'tpope/vim-scriptease'
" Plug 'Rykka/clickable.vim'
" Plug 'Rykka/clickable-things'
" if ! has( 'lua' )
"     " BEGIN: Shougo/neocomplcache.vim
"     Plug 'Shougo/neocomplcache.vim', {
"                 \ 'on' : 'NeoComplCacheEnable' }
"     Plug 'ujihisa/neco-look' 
"     " END: Shougo/neocomplcache.vim
" else
"     " BEGIN: Shougo/neocomplete.vim
"     Plug 'Shougo/neocomplete.vim', {
"                 \ 'on' : 'NeoCompleteEnable' }
"     Plug 'mopp/googlesuggest-source.vim'
"     Plug 'mattn/googlesuggest-complete-vim'
"     Plug 'mattn/webapi-vim'
"     Plug 'ujihisa/neco-look'
"     " END: Shougo/neocomplete.vim
" endif
" Plug 'SirVer/ultisnips'
" Plug 'ahayman/vim-nodejs-complete', {
"             \ 'for' : [ 'javascript', 'json', 'jsx', 'typescript', 'html', 'css', 'php' ] }
" Plug 'pangloss/vim-javascript', {
"             \ 'for' : [ 'javascript', 'json', 'jsx', 'typescript', 'html', 'css', 'php' ] }
" Plug 'Igorjan94/codeforces.vim'
" Plug 'octol/vim-cpp-enhanced-highlight', {
"             \ 'for' : [ 'cpp', 'c' ] }
" Plug 'hdima/python-syntax', {
"             \ 'for' : [ 'python', 'vim' ] }
" Plug 'vim-perl/vim-perl', {
"             \ 'for' : 'perl' }
" Plug 'HerringtonDarkholme/yats.vim', {
"             \ 'for' : [ 'javascript', 'json', 'jsx', 'typescript', 'html', 'css', 'php' ] }
" Plug 'wavded/vim-stylus'
" Plug 'pangloss/vim-javascript', {
"             \ 'for' : [ 'javascript', 'json', 'jsx', 'typescript', 'html', 'css', 'php' ] }
" Plug 'MaxMEllon/vim-jsx-pretty', {
"             \ 'for' : [ 'javascript', 'json', 'jsx', 'typescript', 'html', 'css', 'php' ] }
" " No lazy-loading for digitaltoad/vim-jade.
" " It must be started by default
" Plug 'digitaltoad/vim-jade'
" Plug 'elzr/vim-json', {
"             \ 'for' : [ 'javascript', 'json', 'jsx', 'typescript', 'html', 'css', 'php' ] }
" Plug 'MPogoda/octave.vim--', {
"             \ 'for' : 'octave' }
" Plug 'ingydotnet/yaml-vim', {
"             \ 'for' : 'yaml' }
" Plug 'pearofducks/ansible-vim', {
"             \ 'for' : [ 'ansible', 'ansible_template', 'ansible_hosts' ] }
" Plug 'StanAngeloff/php.vim', {
"             \ 'for' : 'php' }

" " Plugins (i3wm)
" Plug 'PotatoesMaster/i3-vim-syntax', {
"             \ 'for' : 'i3' }
" Plug 'mboughaba/i3config.vim'
" Plug 'chrisbra/Colorizer', {
"             \ 'for' : [ 'css', 'html', 'xhtml', 'javascript', 'json', 'jsx', 
"             \           'typescript', 'html', 'php' ] }
" Plug 'liuchengxu/vista.vim'
" Plug 'ap/vim-css-color'
" Plug 'LeafCage/yankround.vim'
" Plug 'pechorin/any-jump.vim'
" if !has('nvim')
"     Plug 'aymericbeaumet/vim-symlink'
" endif
" " BEGIN: Shougo/unite.vim
" Plug 'Shougo/unite.vim'
" Plug 'Shougo/neomru.vim'
" Plug 'osyo-manga/unite-quickfix'
" Plug 'Shougo/unite-outline'
" Plug 'Shougo/unite-help'
" Plug 'thinca/vim-unite-history'
" Plug 'tacroe/unite-mark'
" Plug 'ujihisa/unite-launch'
" Plug 'thinca/vim-quickrun'
" Plug 'm2mdas/unite-file-vcs'
" Plug 'thinca/vim-ref'
" Plug 'kmnk/vim-unite-giti'
" Plug 'osyo-manga/vim-reanimate'
" " Plug 'chrisbra/BufTimer', {
" "             \ 'on' : [ 'BufTimer', 'BufTimerReport' ] }
" " END: Shougo/unite.vim
" Plug 'airblade/vim-rooter'
" " BEGIN: francoiscabrol/ranger.vim
" Plug 'francoiscabrol/ranger.vim'
" " END:francoiscabrol/ranger.vim
" Plug 'haorenW1025/floatLf-nvim', {
"             \ 'on' : [ 'LfToggle', 'LfToggleCurrentBuf' ] }

" Plug 'dhruvasagar/vim-zoom'

" " vim-zoom settings
" nmap f <Plug>(zoom-toggle)=
" vZoom.vim settings
" Plug 'Valloric/MatchTagAlways', {
"             \ 'for' : [ 'html', 'xhtml', 'xml', 'jinja', 'php', 'jsp',
"             \           'htmldjango' ] }
" " BEGIN: sukima/xmledit
" let g:xmleditPath = g:vimPath . '/plugged/xmledit/ftplugin/'
" Plug 'sukima/xmledit', {
"             \ 'do' : 'ln -s -f ' . g:xmleditPath . 'xml.vim ' . g:xmleditPath . 'html.vim; ' .
"             \        'ln -s -f ' . g:xmleditPath . 'xml.vim ' . g:xmleditPath . 'xhtml.vim; ' .
"             \        'ln -s -f ' . g:xmleditPath . 'xml.vim ' . g:xmleditPath . 'jinja.vim; ' .
"             \        'ln -s -f ' . g:xmleditPath . 'xml.vim ' . g:xmleditPath . 'php.vim; ' .
"             \        'ln -s -f ' . g:xmleditPath . 'xml.vim ' . g:xmleditPath . 'jsp.vim; ' .
"             \        'ln -s -f ' . g:xmleditPath . 'xml.vim ' . g:xmleditPath . 'htmldjango.vim; ',
"             \ 'for' : [ 'html', 'xhtml', 'xml', 'jinja', 'php', 'jsp',
"             \           'htmldjango' ] }
" " END: sukima/xmledit

" MatchTagAlways settings
let g:mta_filetypes = { 'html' : 1, 'xhtml' : 1, 'xml' : 1, 'jinja' : 1, 'php' : 1, 'jsp' : 1, }
let g:mta_use_matchparen_group=0
let g:mta_set_default_matchtag_color=1
nnoremap <Space>t :MtaJumpToOtherTag<CR>

autocmd BufEnter * :highlight MatchTag ctermfg=8 ctermbg=lightblue guifg=#002b36 guibg=lightblue

function! CustomLightlineZoomed()
    if exists('*zoom#statusline') && zoom#statusline() == 'zoomed'
        return ''
    else
        return ''
    endif
endfunction

" floatLf-nvim settinngs
let g:floatLf_autoclose = 1
let g:floatLf_border = 1
let g:floatLf_topleft_border = '┌'
let g:floatLf_topright_border = '┐' 
let g:floatLf_botleft_border = '└' 
let g:floatLf_botright_border = '┘' 
let g:floatLf_vertical_border = '│' 
let g:floatLf_horizontal_border = '─' 
let g:floatLf_lf_close = 'q'
let g:floatLf_lf_open = 'oo'
let g:floatLf_lf_split = 'ov'
let g:floatLf_lf_vsplit = 'oh'
let g:floatLf_lf_tab = 'ot'

" floatLf-nvim settings
" fzf-preview.vim settings
" autocmd TermOpen * setlocal nonumber norelativenumber filetype=terminal
autocmd TermOpen * setlocal filetype=terminal
autocmd TermLeave * set shell=bash\ --login
autocmd TermClose * if &filetype !=# 'floaterm' && &filetype !=# 'fzf' | bd! | endif

" bclose.vim settings
let g:bclose_no_plugin_maps = 1

" " ranger.vim settings
" let g:NERDTreeHijackNetrw = 0 " add this line if you use NERDTree
" let g:ranger_replace_netrw = 1 " open ranger when vim open a directory
" let g:ranger_map_keys = 0
" nnoremap <localleader>f :Ranger<CR>
" nnoremap F :FloatermNew ranger<CR>

" " vim-rooter settings
" if exists('g:custom_rooter_targets')
"   let g:rooter_targets = g:custom_rooter_targets
" else
"   let g:rooter_targets = '/,*'
" endif
" let g:rooter_targets = '/,*'
" let g:rooter_patterns = [ '.git', '_darcs', '.hg', '.bzr', '.svn', 'Makefile', 'CMakeLists.txt' ]
" if exists('g:custom_rooter_patterns')
"   let g:rooter_patterns += g:custom_rooter_patterns
" endif
" let g:rooter_manual_only = 1
" let g:rooter_silent_chdir = 1
" let g:rooter_resolve_links = 1
" let g:rooter_change_directory_for_non_project_files = 'current'

    " " vim-rooter settings
    " autocmd BufEnter,BufWinEnter * :Rooter

" nnoremap <localleader>/ :execute "/" . escape(expand("<cword>"), g:escapeChars)<CR>
" nnoremap <localleader>// :execute "/" . escape(expand("<cWORD>"), g:escapeChars)<CR>
" nnoremap <localleader>? :execute "?" . escape(expand("<cword>"), g:escapeChars)<CR>
" nnoremap <localleader>?? :execute "?" . escape(expand("<cWORD>"), g:escapeChars)<CR>
" vnoremap <localleader>/ "ay :execute "/" . escape(@a, g:escapeChars)<CR>
" vnoremap <localleader>? "ay :execute "?" . escape(@a, g:escapeChars)<CR>
" nnoremap <localleader>/g :execute "vimgrep /" . escape(expand("<cword>"), g:escapeChars) . "/gj ./**/*"<CR> :Unite quickfix -toggle -wrap<CR>
" nnoremap <localleader>//g :execute "vimgrep /" . escape(expand("<cWORD>"), g:escapeChars) . "/gj ./**/*"<CR> :Unite quickfix -toggle -wrap<CR>
" vnoremap <localleader>/g "ay :execute "vimgrep /" . escape(@a, g:escapeChars) . "/gj ./**/*"<CR> :Unite quickfix -toggle -wrap<CR>

" Open Ranger inside Vim
function! RangeChooser()
    let temp = tempname()
    " The option "--choosefiles" was added in ranger 1.5.1. Use the next line
    " with ranger 1.4.2 through 1.5.0 instead.
    "exec 'silent !ranger --choosefile=' . shellescape(temp)
    exec 'silent !ranger --choosefiles=' . shellescape(temp)
    if !filereadable(temp)
        redraw!
        " Nothing to read.
        return
    endif
    let names = readfile(temp)
    if empty(names)
        redraw!
        " Nothing to open.
        return
    endif
    " Edit the first item.
    exec 'edit ' . fnameescape(names[0])
    " Add any remaning items to the arg list/buffer list.
    for name in names[1:]
        exec 'argadd ' . fnameescape(name)
    endfor
    redraw!
endfunction

command! -bar RangerChooser call RangeChooser()
nnoremap <localleader>f :<C-U>RangerChooser<CR>

" unite.vim settings
let g:unite_no_default_keymappings = 1
let g:unite_redraw_hold_candidates = 50000
let g:unite_source_rec_max_cache_files = 0
let g:unite_data_directory = g:vimPath . '/cache/unite'
" nnoremap <leader>b :silent! Unite buffer -prompt=Buf>\ \  -winheight=10 -start-insert -buffer-name=Buffers\ List<CR>
" nnoremap <leader>w :silent! Unite window -prompt=Win>\ \  -winheight=10 -start-insert -buffer-name=Windows\ List<CR>
" nnoremap <leader>t :silent! Unite tab -prompt=Tab>\ \  -winheight=10 -start-insert -buffer-name=Tabs\ List<CR>
" " nnoremap <leader>rb :silent! Unite buffer -start-insert -buffer-name=ub -resume<CR>
" " nnoremap <leader>o :silent! Unite file_rec/async -start-insert -buffer-name=uo<CR>
" " nnoremap <leader>ro :silent! Unite file_rec/async -start-insert -buffer-name=uo -resume<CR>
" " nnoremap <leader>o :silent! Unite file_rec/async -start-insert -buffer-name=uo<CR>
" " nnoremap <leader>ro :silent! Unite file_rec/async -start-insert -buffer-name=uo -resume<CR>
" nnoremap <leader>q :silent! Unite quickfix -auto-highlight -start-insert -buffer-name=Quickfix<CR>
" " nnoremap <leader>rq :silent! Unite quickfix -start-insert -buffer-name=Quickfix -resume<CR>
" nnoremap <leader>i :silent! Unite -prompt=Interactive>\ \  -auto-preview -start-insert -buffer-name=Interactive<CR>
" " nnoremap <leader>ri :silent! Unite -auto-preview -start-insert -buffer-name=Interactive -resume<CR>
" " nnoremap <leader>g :silent! Unite grep -prompt=Grep>\ \  -no-quit -keep-focus -no-auto-preview -auto-highlight -start-insert -buffer-name=Grep<CR>
" " nnoremap <leader>rg :silent! Unite grep -prompt=Grep>\ \  -no-quit -keep-focus -no-auto-preview -auto-highlight -start-insert -buffer-name=Grep -resume<CR>
" " nnoremap <leader>f :silent! Unite find -start-insert -buffer-name=uf<CR>
" nnoremap <leader>f :NeoMRURec<CR> 
" nnoremap <leader>M :silent! Unite -prompt=Maps(n)>\ \  mapping -auto-highlight -start-insert -buffer-name=Normal\ Mode\ Mappings<CR>
" nnoremap <leader>m :silent! Unite -prompt=BMarks>\ \  vim_bookmarks -auto-highlight -start-insert -buffer-name=Bookmarks<CR>
" nnoremap <leader>j :silent! Unite -prompt=Jumps>\ \  jump -auto-highlight -start-insert -buffer-name=Jumps<CR>
" " nnoremap <leader>rf :silent! Unite find -start-insert -buffer-name=uf -resume<CR>
" nnoremap <leader>/ :silent! Unite -prompt=Hist(/)>\ \  history/search -start-insert -buffer-name=Search\ History<CR>
" nnoremap <leader>c :silent! Unite -prompt=Changes>\ \  change -auto-highlight -start-insert -buffer-name=Change\ History<CR>
" nnoremap <leader>T :silent! Unite -prompt=Ctags>\ \  outline -auto-highlight -winheight=20 -prompt-direction=top -start-insert -buffer-name=Ctags<CR>
" " nnoremap <leader>hr/ :silent! Unite history/search -start-insert -buffer-name=u/ -resume<CR>
" nnoremap <leader>; :silent! Unite -prompt=Hist(:)>\ \  history/command command -auto-highlight -start-insert -buffer-name=Command\ History<CR>
" " nnoremap <leader>hr; :silent! Unite history/command -start-insert -buffer-name=u/ -resume<CR>


" nnoremap <leader>sl :silent! Unite -start-insert -default-action=reanimate_load -buffer-name=Sessions -prompt=Sessions>\  reanimate<CR>
" nnoremap <leader>se :silent! Unite -start-insert -buffer-name=Sessions -prompt=Sessions>\  reanimate<CR>
" nnoremap <leader>S :silent! Unite -prompt=Hist($_)>\ \  -auto-highlight -start-insert -buffer-name=Shell\ History output/shellcmd:tac\ $HOME/.shell_history\ \|\ grep\ -v\ '^$'\ \|\ head\ jj
" nnoremap <leader>B :silent! Unite -prompt=BufTimer>\ \  -auto-highlight -start-insert -buffer-name=Buffer\ Timer output:BufTimerReport<CR>
" nnoremap " :silent! Unite -prompt=Regs(")>\ \  register -auto-highlight -start-insert -buffer-name=Registers<CR>
" nnoremap M :silent! Unite -prompt=Msgs>\ \  -auto-highlight -start-insert -buffer-name=Messages\ History output:message<CR>
" nnoremap <leader>hrs :silent! Unite -start-insert -buffer-name=sh -resume output/shellcmd:tac\ $HOME/.shell_history\ \|\ grep\ -v\ '^$'\ \|\ head\ -n\ 1000\ -<CR>
" nnoremap <leader><localleader>/ :silent! Unite -no-auto-resize -auto-highlight -winheight=20 -prompt-direction=top -start-insert -buffer-name=Current\ Buffer -prompt=BLines>\ \  line:all<CR>
" nnoremap <leader><leader>/ :silent! Unite -no-auto-resize -auto-highlight -winheight=20 -prompt-direction=top -start-insert -buffer-name=All\ Buffers -prompt=Lines>\ \  line:buffers<CR>
let g:unite_split_rule = 'botright'

" neomru.vim settings
nnoremap oo :NeoMRU<Space>
nnoremap <localleader>v :split<CR>:NeoMRU<CR>
nnoremap <localleader>h :vsplit<CR>:NeoMRU<CR>
nnoremap <localleader>t :tabnew<CR>:NeoMRU<CR>
nnoremap <leader>sf :call ToggleSearchFoldOpen()<CR>
nnoremap ov :NeoMRUSplit<Space>
nnoremap oh :NeoMRUVSplit<Space>
nnoremap OV :NeoMRUTopSplit<Space>
nnoremap OH :NeoMRULeftVSplit<Space>
nnoremap t :NeoMRUTab<Space>
let g:neomru#file_mru_path = $HOME . "/.vim/cache/neomru/file"
let g:neomru#directory_mru_path = $HOME . "/.vim/cache/neomru/directory"
" nnoremap O :NeoMRU<CR>
nnoremap <leader>o :execute "NeoMRU ./"<CR>
let g:neomru#file_mru_limit = 1000000 
let g:neomru#directory_mru_limit = 1000000 
let g:unite_source_file_mru_limit = 1000000 
let g:unite_source_directory_mru_limit = 1000000 

function! InvokeNeoMRU(...)
    let l:arg = join( a:000, '\\ ' )
    if ( l:arg != '' )
        if ! isdirectory( expand( l:arg ) )
            execute "edit " . l:arg
        else
            execute "FZFFiles " . l:arg
            " execute "silent! Unite -prompt=Open>\\ \\  directory:" . l:arg . " directory_mru buffer file_mru file/async:" . l:arg . " file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
        endif
    else
        execute "FzfMruFiles"
        " execute "silent! Unite -prompt=Open>\\ \\  directory directory_mru buffer file_mru file/async file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
    endif
endfunction
command! -nargs=* -complete=file NeoMRU call InvokeNeoMRU( <f-args> )
nnoremap <localleader>o :NeoMRU<CR>

function! InvokeNeoMRUVSplit(...)
    let l:arg = join( a:000, '\\ ' )
    if ( l:arg != '' )
        if ! isdirectory( expand( l:arg ) )
            execute "vsplit " . l:arg
        else
            execute "vsplit"
            execute "FZFFiles " . l:arg
            " execute "silent! Unite -prompt=Open>\\ \\  directory:" . l:arg . " directory_mru buffer file_mru file/async:" . l:arg . " file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
        endif
    else
        execute "vsplit"
        execute "FzfMruFiles"
        " execute "silent! Unite -prompt=Open>\\ \\  directory directory_mru buffer file_mru file/async file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
    endif
endfunction
command! -nargs=* -complete=file NeoMRUVSplit call InvokeNeoMRUVSplit( <f-args> )

function! InvokeNeoMRUSplit(...)
    let l:arg = join( a:000, '\\ ' )
    if ( l:arg != '' )
        if ! isdirectory( expand( l:arg ) )
            execute "split " . l:arg
        else
            execute "split"
            execute "FZFFiles " . l:arg
            " execute "silent! Unite -prompt=Open>\\ \\  directory:" . l:arg . " directory_mru buffer file_mru file/async:" . l:arg . " file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
        endif
    else
        execute "split"
        execute "FzfMruFiles"
        " execute "silent! Unite -prompt=Open>\\ \\  directory directory_mru buffer file_mru file/async file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
    endif
endfunction
command! -nargs=* -complete=file NeoMRUSplit call InvokeNeoMRUSplit( <f-args> )

function! InvokeNeoMRULeftVSplit(...)
    set nosplitright
    let l:arg = join( a:000, '\\ ' )
    if ( l:arg != '' )
        if ! isdirectory( expand( l:arg ) )
            execute "vsplit " . l:arg
        else
            execute "vsplit"
            execute "FZFFiles " . l:arg
            " execute "silent! Unite -prompt=Open>\\ \\  directory:" . l:arg . " directory_mru buffer file_mru file/async:" . l:arg . " file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
        endif
    else
        execute "vsplit"
        execute "FzfMruFiles"
        " execute "silent! Unite -prompt=Open>\\ \\  directory directory_mru buffer file_mru file/async file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
    endif
    set splitright
endfunction
command! -nargs=* -complete=file NeoMRULeftVSplit call InvokeNeoMRULeftVSplit( <f-args> )

function! InvokeNeoMRUTopSplit(...)
    set nosplitbelow
    let l:arg = join( a:000, '\\ ' )
    if ( l:arg != '' )
        if ! isdirectory( expand( l:arg ) )
            execute "split " . l:arg
        else
            execute "split"
            execute "FZFFiles " . l:arg
            " execute "silent! Unite -prompt=Open>\\ \\  directory:" . l:arg . " directory_mru buffer file_mru file/async:" . l:arg . " file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
        endif
    else
        execute "split"
        execute "FzfMruFiles"
        " execute "silent! Unite -prompt=Open>\\ \\  directory directory_mru buffer file_mru file/async file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
    endif
    set splitbelow
endfunction
command! -nargs=* -complete=file NeoMRUTopSplit call InvokeNeoMRUTopSplit( <f-args> )

function! InvokeNeoMRUTab(...)
    let l:arg = join( a:000, '\\ ' )
    if ( l:arg != '' )
        if ! isdirectory( expand( l:arg ) )
            execute "tabnew " . l:arg
        else
            execute "tabnew"
            execute "FZFFiles " . l:arg
            " execute "silent! Unite -prompt=Open>\\ \\  directory:" . l:arg . " directory_mru buffer file_mru file/async:" . l:arg . " file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
        endif
    else
        execute "tabnew"
        execute "FzfMruFiles"
        " execute "silent! Unite -prompt=Open>\\ \\  directory directory_mru buffer file_mru file/async file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
    endif
endfunction
command! -nargs=* -complete=file NeoMRUTab call InvokeNeoMRUTab( <f-args> )

function! InvokeNeoMRURec(...)
    let l:arg = join( a:000, '\\ ' )
    if ( l:arg != '' )
        if ! isdirectory( expand( l:arg ) )
            execute "edit " . l:arg
        else
            execute "FZFFiles " . l:arg
            " execute "silent! Unite -prompt=Open>\\ \\  directory_mru buffer file_mru file_rec/async:" . l:arg . " file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
        endif
    else
        execute "FzfMruFiles"
        " execute "silent! Unite -prompt=Open>\\ \\  directory_mru buffer file_mru file_rec/async file/new -start-insert -buffer-name=Open\\ Files\\ and\\ Directories"
    endif
endfunction
command! -nargs=* -complete=file NeoMRURec call InvokeNeoMRURec( <f-args> )
" nnoremap <leader>hro :silent! Unite file_mru directory_mru buffer -start-insert -buffer-name=mru -resume<CR>

let g:unite_source_find_command = 'find'
let g:unite_source_find_default_opts = ''
let g:unite_source_find_default_expr = '-mount -iname "**"'
let g:unite_source_find_max_candidates = 0

if executable('rg')
    let g:unite_source_grep_command = 'rg'
    let g:unite_source_grep_default_opts = '--no-messages --smart-case --vimgrep'
    let g:unite_source_grep_recursive_opt = ''
    let g:unite_source_grep_search_word_highlight = 'Error'
elseif executable('grep')
    let g:unite_source_grep_command = 'grep'
    let g:unite_source_grep_default_opts = '-F -s -n -H -I -i --exclude-dir={.git,.svn,cmake-build-debug,.idea,CMakeFiles} -r'
    let g:unite_source_grep_recursive_opt = '-r'
    let g:unite_source_grep_search_word_highlight = 'Error'
endif

highlight default link uniteSource__GrepFile helpVim
highlight default link uniteSource__GrepLineNr Statement

function! CustomizeUnite()
    if exists('*unite#custom#source')
        call unite#custom#source('grep', 'max_candidates', 0)
    endif
    if exists('*unite#custom#source')
        call unite#custom#source('session', 'sorters', 'sorter_reverse')
    endif
endfunction


    " unite.vim settings
    autocmd BufWinEnter,FileType unite :call ConfigureUnite()
    autocmd VimEnter * :call CustomizeUnite()
    autocmd FileType unite let b:coc_suggest_disable = 1

function! ConfigureUnite()
    if ( &filetype ==# 'unite' )
        " :execute "silent! NumbersDisable"

        if ( expand( '%p' ) =~ '.*Current Buffer.*' ) || ( expand( '%p' ) =~ '.*All Buffers.*' )
            " execute "normal! gg"
            inoremap <buffer> <BS> <C-c>ggxA
            nnoremap <buffer> <C-u> gg0DA
            inoremap <buffer> <C-u> <C-c>:execute "normal! gg"<CR>:execute "normal! 0D"<CR>A
            onoremap <buffer> <C-u> <C-c>:execute "normal! gg"<CR>:execute "normal! 0D"<CR>A
            xnoremap <buffer> <C-u> <C-c>:execute "normal! gg"<CR>:execute "normal! 0D"<CR>A
            snoremap <buffer> <C-u> <C-c>:execute "normal! gg"<CR>:execute "normal! 0D"<CR>A
        else
            " execute "normal! G"
            inoremap <buffer> <BS> <C-c>GxA
            nnoremap <buffer> <C-u> G0DA
            inoremap <buffer> <C-u> <C-c>:execute "normal! G"<CR>:execute "normal! 0D"<CR>A
            onoremap <buffer> <C-u> <C-c>:execute "normal! G"<CR>:execute "normal! 0D"<CR>A
            xnoremap <buffer> <C-u> <C-c>:execute "normal! G"<CR>:execute "normal! 0D"<CR>A
            snoremap <buffer> <C-u> <C-c>:execute "normal! G"<CR>:execute "normal! 0D"<CR>A
        endif
        " execute "normal! \<C-o>"
        " nnoremap <silent><buffer><expr> <CR> unite#do_action('default')
        nmap <buffer> <CR> <Plug>(unite_do_default_action) 
        imap <buffer> <CR> <Plug>(unite_do_default_action)

        imap <buffer> <Tab> <Plug>(unite_do_default_action)
        nmap <buffer> <Tab> <Plug>(unite_do_default_action) 

        imap <buffer><expr> <C-j> pumvisible() ? "\<C-n>" : '<Plug>(unite_select_next_line)'
        imap <buffer><expr> <C-k> pumvisible() ? "\<C-p>" : '<Plug>(unite_select_previous_line)'
        imap <buffer> <C-r> <Plug>(unite_delete_backward_word)
        imap <buffer><expr> <C-p> pumvisible() ? "\<C-p>" : ''
        nmap <buffer> h h
        nnoremap <silent><buffer><expr><C-d> unite#do_action('delete')

        inoremap <buffer> jk <C-c>
        onoremap <buffer> jk <C-c>
        xnoremap <buffer> jk <C-c>
        snoremap <buffer> jk <C-c>

        setlocal nonumber norelativenumber
    endif
endfunction

" unite_quickfix settings
let g:unite_quickfix_filename_is_pathshorten = 0


if exists('*unite#custom#profile')
    call unite#custom#profile( 'default', 'context', {
                \ 'direction' : 'botright',
                \ 'prompt' : '>>>>> ',
                \ 'auto_resize' : 1,
                \ 'prompt_focus' : 1,
                \ 'start_insert' : 1,
                \ 'toggle' : 1,
                \ 'wrap' : 0,
                \ 'winheight' : 30,
                \ 'previewheight' : 30,
                \ 'auto_highlight' : 0,
                \ 'force_redraw' : 1,
                \ 'unite__disable_max_candidates' : 1,
                \ } )
endif
highlight default link uniteInputPrompt Identifier
highlight default link uniteCandidateInputKeyword PreProc
highlight default link uniteInputLine Normal
highlight default link uniteQuickMatchText Identifier
highlight uniteCandidateSourceName ctermfg=4
let g:unite_source_line_enable_highlight = 0
let g:unite_source_rec_find_args = [
            \ '-path', "*.git/*", '-prune', '-o',
            \ '-path', "*cmake-build-debug/*", '-prune', '-o',
            \ '-path', "*CMakeFiles/*", '-prune', '-o',
            \ '-path', '*.idea/*', '-prune', '-o',
            \ '(', '-type', 'f', '-o', '-type', 'l', ')', '-print' ]
let g:unite_enable_auto_select = 0

" " any-jump.vim settings
" let g:any_jump_colors = {
"             \ "plain_text":         "Comment",
"             \ "preview":            "Comment",
"             \ "preview_keyword":    "Operator",
"             \ "heading_text":       "Function",
"             \ "heading_keyword":    "Identifier",
"             \ "group_text":         "Comment",
"             \ "group_name":         "helpVim",
"             \ "more_button":        "Operator",
"             \ "more_explain":       "Comment",
"             \ "result_line_number": "Statement",
"             \ "result_text":        "Normal",
"             \ "result_path":        "helpVim",
"             \ "help":               "Comment"
"             \ }
" let g:any_jump_grouping_enabled = 1

" " yankround.vim settings
" let g:yankround_dir = g:vimPath
" let g:yankround_max_history = 10000000
" let g:yankround_max_element_length = 10000000

" unite-session settings
function! SaveSessionUnite(...)
    let l:arg = join( a:000, '_' )
    if ( l:arg != '' )
        execute "silent! UniteSessionSave " . strftime("%Y-%m-%d_%H-%M-%S") . "_" . l:arg  . ".vim"
    elseif exists( '${TMUX}' )
        execute "silent! UniteSessionSave " . strftime("%Y-%m-%d_%H-%M-%S") . "_" . substitute(system("tmux display-message -p '#W'"), '\n', '', 'g')  . ".vim"
    else
        execute "silent! UniteSessionSave " . strftime("%Y-%m-%d_%H-%M-%S") . ".vim"
    endif
endfunction
command! -nargs=* UniteSaveSession call SaveSessionUnite( <f-args> )
nnoremap <leader>ss :UniteSaveSession<Space>
nnoremap <leader>sl :silent! Unite -start-insert -buffer-name=Sessions -prompt=Sessions>\  session<CR>

" vista.vim settings
nnoremap <localleader>T :Vista!!<CR>
let g:vista_sidebar_width = 40
let g:vista_no_mappings = 0
let g:vista_default_executive = 'coc'

function! CustomLightlineNearest() abort
  return get(b:, 'vista_nearest_method_or_function', '')
endfunction

" Colorizer settings
" let g:colorizer_auto_color = 1
let g:colorizer_auto_filetype='css,html,vim'
let g:colorizer_skip_comments = 0
let g:colorizer_x11_names = 1
let g:colorizer_syntax = 1
let g:colorizer_auto_map = 1

" syntastic settings
" Extra Checkers List:
" clang gcc cppcheck perl flake8 pylint jslint nodejs-jshint php
" php-codesniffer phpmd csslint sh xmllint nodejs-jsonlint mivok/markdownlint
" shellcheck checkstyle mlint perl-critic clang-tools-extra
let g:syntastic_python_python_exe = 'python3'
let g:syntastic_cpp_compiler = 'clang++'
let g:syntastic_cpp_compiler_options = ' -std=c++11'
let g:syntastic_asm_compiler = 'gcc'
let g:syntastic_cpp_checkers = [ 'clang++', 'gcc', 'cppcheck', 'clang_check', 'clang_tidy' ]
let g:syntastic_c_checkers = [ 'gcc', 'cppcheck', 'clang_check', 'clang_tidy' ]
let g:syntastic_enable_perl_checker = 1
let g:syntastic_perl_checkers = [ 'perl', 'podchecker' ]
let g:syntastic_python_checkers = [ 'flake8', 'pylint' ]
let g:syntastic_javascript_checkers = [ 'jslint', 'jshint' ]
let g:syntastic_java_checkers = [ 'javac', 'checkstyle' ]
let g:syntastic_php_checkers = [ 'php', 'phpcs', 'phpmd' ]
let g:syntastic_matlab_checkers = [ 'mlint' ]
let g:syntastic_html_checkers = [ 'tidy', 'jshint' ]
let g:syntastic_css_checkers = [ 'csslint', 'phpcs' ]
let g:syntastic_sh_checkers = [ 'sh', 'shellcheck' ]
let g:syntastic_xml_checkers = [ 'xmllint' ]
let g:syntastic_xslt_checkers = [ 'xmllint' ]
let g:syntastic_zsh_checkers = [ 'zsh', 'shellcheck' ]
let g:syntastic_json_checkers = [ 'jsonlint' ]
let g:syntastic_markdown_checkers = [ 'mdl' ]
" let g:syntastic_vim_checkers = [ 'vint' ]
nnoremap <leader>y :SyntasticCheck<CR>
let g:syntastic_check_on_open = 0
let g:syntastic_check_on_wq = 0
let g:syntastic_mode_map = {
            \ "mode" : "passive",
            \ "active_filetypes" : [],
            \ "passive_filetypes" : [] }
" autocmd BufEnter * :SyntasticCheck


" vim-nerdtree-tabs settings
let g:nerdtree_tabs_open_on_console_startup = 1
let g:nerdtree_tabs_focus_on_files = 1

" delimitMate settings
let g:delimitMate_matchpairs = '(:),[:],{:}'
let g:delimitMate_expand_space = 1
let g:delimitMate_expand_cr = 0
let g:delimitMate_jump_expansion = 0

" vim-unimpaired settings
" vnoremap [x: Encode XML/HTML (visual & selection mode)
" nnoremap [x: Encode XML/HTML (normal mode)
" vnoremap ]x: Decode XML/HTML (visual & selection mode)
" nnoremap ]x: Decode XML/HTML (normal mode)
" vnoremap [y: Encode/Escape XML/HTML (visual & selection mode)
" nnoremap [y: Encode/Escape XML/HTML (normal mode)
" vnoremap ]y: Decode C String (visual & selection mode)
" nnoremap ]y: Decode C String (normal mode)

" vim-abolish settings
" crs: coerce to snake_case
" crm: coerce to MixedCase
" crc: coerce to camelCase
" cru: coerce to UPPER_CASE

" " vim-expand-region
" Conflicting with snipMate - must find another key bindings soon
" vmap + <Plug>(expand_region_expand)
" vmap - <Plug>(expand_region_shrink)

" if has( 'clipboard' ) || has( 'xterm_clipboard' )
"    " neoyank.vim settings
"    nnoremap <leader>p :silent! Unite -prompt=Hist(dy)>\ \  history/yank -start-insert -buffer-name=Yank\ History<CR>
"    xnoremap <silent> p "_dP
"    " nnoremap yy yy:call neoyank#update()<CR>
"    " nnoremap dd dd:call neoyank#update()<CR>
"    " xnoremap y y<C-c>:call neoyank#update()<CR>
"    " xnoremap d d<C-c>:call neoyank#update()<CR>
"    let g:neoyank#limit = 1000000
"    let g:neoyank#length = 10000000
"    let g:neoyank#file = $HOME . "/.vim/cache/neoyank/yank_history.txt"
" endif

" " neoyank.vim settings
" autocmd TextYankPost,TextChanged,VimLeavePre,WinEnter,BufWinEnter,CursorMoved,FocusGained,FocusLost * :silent! call neoyank#_append()

" vim-hopping settings
" let g:hopping#keymapping = {
"             \	"\<C-n>" : "<Over>(hopping-next)",
"             \	"\<C-p>" : "<Over>(hopping-prev)",
"             \	"\<C-k>" : "<Over>(scroll-u)",
"             \	"\<C-j>" : "<Over>(scroll-d)", }
" let g:hopping#prompt = "Filter:> "
" command! -bang -nargs=* FZFBLines call fzf#vim#buffer_lines(<q-args>, {'options': '--reverse'}, <bang>0)
" command! -bang -nargs=* FZFLines call fzf#vim#lines(<q-args>, {'options': '--reverse'}, <bang>0)
" command! -bang -nargs=* FZFBTags  call fzf#vim#buffer_tags(<q-args>, {'options': '--reverse'}, <bang>0)
" nnoremap <leader><localleader>/ :FzfBLines<CR>
" nnoremap <leader><leader>/ :FzfLines<CR>

" vim-foldfocus settings
" nnoremap <localleader>fh :call FoldFocus('vnew')<CR>
" nnoremap <localleader>fv :call FoldFocus('new')<CR>
" nnoremap <localleader>ft :call FoldFocus('tabedit')<CR>

" vim-exchange settings
let g:exchange_indent = '=='
" cx : On first use, define the first {motion} to exchange.
"      ON second use, define the second {motion} AND perform exchange.
"      => {motion} here are text objects
"      => cxiw : Exchange 2 words
" cxx : Like cx, but use the current line
" X : Like cx, but for visual mode
" cxc : Clear any {motion} pending for exchange


    " id3.vim settings
    autocmd BufRead *.mp3 set filetype=mp3

" vim-argumentative settings
" <, and >, : Shifting arguments
" [, and ], : Moving between argument boundaries
" => Extra textobj:
" a, : Select argument undercursor, including leading/trailing white space
"      AND comma (,) separator
" i, : Select argument undercursor only, without leading/trailing white space
"      OR comma (,) separator
let g:argumentative_no_mappings = 1
nmap .[ <Plug>Argumentative_Prev
nmap .] <Plug>Argumentative_Next
xmap .[ <Plug>Argumentative_XPrev
xmap .] <Plug>Argumentative_XNext
nmap .< <Plug>Argumentative_MoveLeft
nmap .> <Plug>Argumentative_MoveRight
xmap i, <Plug>Argumentative_InnerTextObject
xmap a, <Plug>Argumentative_OuterTextObject
omap i, <Plug>Argumentative_OpPendingInnerTextObject
omap a, <Plug>Argumentative_OpPendingOuterTextObject

" NrrwRgn settings
let g:nrrw_rgn_nohl = 1
let g:nrrw_rgn_wdth = 40
vnoremap <leader>e :NR<CR>

" changesPlugin settings
let g:changes_sign_text_utf8 = 0
nnoremap <localleader>sh <Plug>(ChangesStageHunk)
nnoremap <localleader>sr <Plug>(ChangesStageHunkRevert)
" changesPlugin's highlights
highlight ChangesSignTextAdd ctermbg=2 ctermfg=8
highlight ChangesSignTextDel ctermbg=1 ctermfg=8
highlight ChangesSignTextCh ctermbg=3 ctermfg=8

" current-func-info.vim settings
nnoremap <leader>? :echom cfi#get_func_name()<CR>

" mulfiles.vim settings

" " vim-ping-cursor
" function! PingCursor()
"    " highlight CursorColumn ctermbg=0 guibg=Grey40
"    " highlight CursorLine ctermbg=0 guibg=Grey40
"    set nocursorline nocursorcolumn
"    redraw
"    execute 'sleep 200m'
"    set cursorline cursorcolumn
" endfunction
" nnoremap <CR> :redraw!<CR>:call PingCursor()<CR>

" vim-cursorword settings
" autocmd SourcePre * :highlight! CursorWord0 ctermbg=0 cterm=underline

" vim-github-dashboard settings
nnoremap <localleader>ga :GHActivity<Space>
nnoremap <localleader>gd :GHDashboard<Space>

" limelight.vim settings
nnoremap FL :Limelight!!<CR>
" Color name (:help cterm-colors) or ANSI code
let g:limelight_conceal_ctermfg = '10'

" Color name (:help gui-colors) or RGB color
let g:limelight_conceal_guifg = '10'

" Default: 0.5
let g:limelight_default_coefficient = 1.0

" Number of preceding/following paragraphs to include (default: 0)
let g:limelight_paragraph_span = 1

" Beginning/end of paragraph
"   When there's no empty line between the paragraphs
"   and each paragraph starts with indentation
" let g:limelight_bop = '^\s'
" let g:limelight_eop = '\ze\n^\s'

" Highlighting priority (default: 10)
"   Set it to -1 not to overrule hlsearch
let g:limelight_priority = -1


" " vim-peekaboo settings
" let g:peekaboo_window = 'botright 30new'

" fzf.vim settings
" nnoremap <leader><localleader>f :FzfFiles<Space>
" nnoremap <leader><localleader>b :FzfBuffers<CR>
" nnoremap <leader><localleader>L :FzfLines<CR>
" nnoremap <leader><localleader>l :FzfBLines<CR>
" nnoremap <leader><localleader>w :FzfWindows<CR>
" nnoremap <leader><localleader>H :FzfHistory<CR>
" nnoremap <leader><localleader>h/ :FzfHistory/<CR>
" nnoremap <leader><localleader>h: :FzfHistory:<CR>
" nnoremap <leader><localleader>c :FzfCommits<CR>
" nnoremap <leader><localleader>C :FzfBCommits<CR>
" let g:fzf_command_prefix = 'Fzf'
" let g:fzf_layout = { 'down': '30' }

" " fzf-mru.vim settings
" let g:fzf_mru_relative = 0
" let g:fzf_mru_case_sensitive = 0
" let g:fzf_mru_max = 1000
" let g:fzf_mru_exclude = ".*unite.*"
" nnoremap <leader>o :FZFMru<CR>
" function StartFZFMru()
"     if !argc() && !exists('g:fzf_mru_disable_at_vimenter') && (&filetype != 'stardict')
"         :FZFMru
"         let t:startified = 1
"     endif
"
"     " :NERDTree
"     " wincmd w
" endfunction
" nnoremap <leader>b :FzfBuffers<CR> 
" nnoremap <leader>m :FzfMaps<CR>
" nnoremap <leader>/ :FzfHistory/<CR>
" nnoremap <leader>; :FzfHistory:<CR>

    " " fzf-mru.vim settings
    " autocmd BufNewFile * :call StartFZFMru()

" lazyList.vim settings
nnoremap <leader>lo :LazyList<CR>
nnoremap <leader>lc :LazyList ''<Left>
vnoremap <leader>lo :LazyList<CR>
vnoremap <leader>lc :LazyList ''<Left>

" rename.vim settings
nnoremap <localleader>mm :Rename!<Space>

" vim-grex settings
nnoremap ym :Grey<CR>
nnoremap dm :Gred<CR>

" vim-foldsearch settings
let g:foldsearch_disable_mappings = 1
let g:foldsearch_highlight = 0
" nnoremap <localleader>fc :set foldmethod=manual<CR>:Fw<CR>
" nnoremap <localleader>f/ :set foldmethod=manual<CR>:Fs<CR>
" nnoremap <localleader>fs :set foldmethod=manual<CR>:Fp<Space>
" nnoremap <localleader>fr :set foldmethod=manual<CR>:Fl<CR>
" nnoremap <localleader>fe zE:set foldmethod=indent<CR>

" " tabman.vim
" let g:tabman_toggle = '<localleader>T'
" let g:tabman_focus = '<localleader>t'
" let g:tabman_width = 25
" let g:tabman_side = 'right'
" let g:tabman_specials = 0
" let g:tabman_number = 0

" scratch settings
nnoremap <leader>sn :Sscratch<CR>
nnoremap <leader>se :Scratch<CR>

" " vim-startify settings
" nnoremap <leader>st :Startify<CR>
" let g:startify_relative_path = 0
" let g:startify_files_number = 10
" let g:startify_session_persistence = 0
" let g:startify_session_autoload = 0
" let g:startify_session_delete_buffers = 1
" let g:startify_change_to_dir = 1
" let g:startify_enable_special = 0
" let g:startify_enable_unsafe = 0
" let g:startify_custom_header = map(split(system('fortune | cowsay'), '\n'), '"   " . v:val') + ['']
" let g:startify_custom_footer = [ '', "   Vim is charityware. Please read ':help uganda'.", '' ]
"
" function StartStartify()
"     if !argc() && !exists('g:startify_disable_at_vimenter') && (&filetype != 'stardict')
"         :FZFMru
"         let t:startified = 1
"     endif
"
"     " :NERDTree
"     wincmd w
" endfunction

" smartpairs.vim settings
" i*, ab : Select text & multiple lines inside *, where * is in <, >, ", ', `, (, ), [, ], {, } or t as tag
" a*, ab : Select text & multiple lines inside *, where * is in <, >, ", ', `, (, ), [, ], {, } or t as tag
" i<symbol> (i", i', i} for example) : Select text surrounded by <symbol>,
"                                      not including <symbol>
let g:smartpairs_key = 'q'
let g:smartpairs_nextpairs_key = 'q'

" vim-togglecursor settings
let g:togglecursor_force = 'xterm'
let g:togglecursor_default = 'blinking_block'

" Gundo settings
let g:gundo_width = 30
let g:gundo_preview_bottom = 1
let g:gundo_right = 1
let t:gundo_is_opened = 0
let g:gundo_prefer_python3 = 1

" Gitv settings
" nnoremap <localleader>gi :Gitv<CR>
let g:Gitv_OpenHorizontal = 1
let g:Gitv_DoNotMapCtrlKey = 1

" vim-marching settings
let g:marching_clang_command = 'clang'
let g:marching#clang_command#options = { 'cpp' : '-std=c++17' }
let g:marching_include_paths = []
let g:marching_enable_neocomplete = 1

" " jedi-vim settings
" let g:jedi#show_call_signatures = 0
" let g:jedi#goto_assignments_command = ""
" let g:jedi#goto_definitions_command = ""
" let g:jedi#documentation_command = "<localleader>mc"
" let g:jedi#usages_command = ""
" let g:jedi#completions_command = ""
" let g:jedi#rename_command = ""
" let g:jedi#popup_on_dot = 0
" let g:jedi#smart_auto_mappings = 0
" let g:jedi#auto_vim_configuration = 0

" PHP-CodeSniffer
let g:syntastic_phpcs_conf=' --standard=DrupalCodingStandard --extensions=php,module,inc,install,test,profile,theme'

" autochmodx.vim
let g:autochmodx_no_BufWritePost_autocmd = 1
let g:autochmodx_no_CursorHold_autocmd = 1
nnoremap <leader>x :AutoChmodRun<CR>

" vim-airline settings
let g:airline_powerline_fonts = 1

" if ( v:version > 704 )
    " let &rtp.=',/usr/lib/python' . PythonExactVersion() . '/site-packages/powerline/bindings/vim/'
    " let &rtp.=',/usr/local/lib/python' . PythonExactVersion() . '/site-packages/powerline/bindings/vim/'
    " let &rtp.=',' . $HOME .'/Library/Python/' . PythonExactVersion() . '/lib/python/site-packages/powerline/bindings/vim/'
" endif
let g:airline_powerline_fonts = 1

" powerline settings
if has("python3")
    let g:powerline_pycmd="py3"
elseif has("python")
endif

" Enable omni completion.
" if has('lua')
"     autocmd FileType java :let g:loaded_neocomplete = 1
" else
"     autocmd FileType java :let g:loaded_neocomplcache = 1
" end

" " neocomplete.vim settings & neocomplcache settings
" "" Disable AutoComplPop.
" let g:acp_enableAtStartup = 0
"
" function EnableAndComplete()
"     if has('lua') && (!exists('neocomplete#is_enabled()') || !neocomplete#is_enabled())
"         NeoCompleteEnable
"         return neocomplete#start_manual_complete()
"     elseif !has('lua') && (!exists('neocomplcache#is_enabled()') || !neocomplcache#is_enabled())
"         NeoComplCacheEnable
"         return neocomplcache#start_manual_complete()
"     endif
" endfunction
"
" if has("unix")
"     let s:uname = system("uname -s")
"     if s:uname == "Darwin"
"         inoremap <expr><C-@> pumvisible() ? "\<C-n>" : EnableAndComplete()
"     else
"         inoremap <expr><C-Backspace> pumvisible() ? "\<C-n>" : EnableAndComplete()
"     endif
" endif
" inoremap <expr><C-j> pumvisible() ? "\<C-n>" : "\<C-j>"
" inoremap <expr><C-k> pumvisible() ? "\<C-p>" : "\<C-k>"
" inoremap <expr><C-r> "\<C-w>"
" inoremap <expr><C-u> "\<C-c>0Di"
" if has('lua')
"     " neocomplete.vim settings
"     " Use neocomplete
"     let g:neocomplete#enable_at_startup = 0
"     let g:neocomplete#data_directory = $HOME . "/.vim/cache/neocomplete"
"     " Use smartcase.
"     let g:neocomplete#enable_ignore_case = 1
"     let g:neocomplete#enable_smart_case = 0
"     " Set minimum syntax keyword length.
"     let g:neocomplete#min_keyword_length = 0
"     let g:neocomplete#lock_buffer_name_pattern = '\*ku\*'
"
"     " Define dictionary.
"     let g:neocomplete#sources#dictionary#dictionaries = {
"                 \ 'default' : '',
"                 \ 'vimshell' : $HOME.'/.vimshell_hist',
"                 \ 'scheme' : $HOME.'/.gosh_completions'
"                 \ }
"
"     " Define keyword.
"     if !exists('g:neocomplete#keyword_patterns')
"         let g:neocomplete#keyword_patterns = {}
"     endif
"     let g:neocomplete#keyword_patterns['default'] = '\h\w*'
"
"     let g:neocomplete#enable_auto_select = 1
"     let g:neocomplete#disable_auto_complete = 1
"
"     " Enable heavy omni completion.
"     if !exists('g:neocomplete#force_omni_input_patterns')
"         let g:neocomplete#force_omni_input_patterns = {}
"     endif
"     let g:neocomplete#force_omni_input_patterns.c =
"                 \ '[^.[:digit:] *\t]\%(\.\|->\)'
"     let g:neocomplete#force_omni_input_patterns.cpp =
"                 \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
"     let g:neocomplete#force_omni_input_patterns.objc =
"                 \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
"     let g:neocomplete#force_omni_input_patterns.objcpp =
"                 \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
"     let g:neocomplete#force_omni_input_patterns.java = '\k\.\k*'
"     let g:neocomplete#force_omni_input_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"     let g:neocomplete#force_omni_input_patterns.python =
"                 \ '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
"
"     " For perlomni.vim setting.
"     " https://github.com/c9s/perlomni.vim
"     let g:neocomplete#force_omni_input_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
"
" else
"     " neocomplcache.vim settings
"     " Use neocomplcache.
"     let g:neocomplcache_enable_at_startup = 0
"     let g:neocomplcache_temporary_dir = $HOME . "/.vim/cache/neocomplcache"
"     " Use smartcase.
"     let g:neocomplcache_enable_ignore_case = 1
"     let g:neocomplcache_enable_smart_case = 0
"     " Set minimum syntax keyword length.
"     let g:neocomplcache_min_syntax_length = 0
"     let g:neocomplete#min_keyword_length = 0
"     let g:neocomplcache_lock_buffer_name_pattern = '\*ku\*'
"
"     " Define dictionary.
"     let g:neocomplcache_dictionary_filetype_lists = {
"                 \ 'default' : '',
"                 \ 'vimshell' : $HOME.'/.vimshell_hist',
"                 \ 'scheme' : $HOME.'/.gosh_completions'
"                 \ }
"
"     " Define keyword.
"     if !exists('g:neocomplcache_keyword_patterns')
"         let g:neocomplcache_keyword_patterns = {}
"     endif
"     let g:neocomplcache_keyword_patterns['default'] = '\h\w*'
"
"     let g:neocomplcache_enable_auto_select = 1
"     let g:neocomplcache_disable_auto_complete = 1
"
"     " Enable heavy omni completion.
"     if !exists('g:neocomplcache_force_omni_patterns')
"         let g:neocomplcache_force_omni_patterns = {}
"     endif
"     let g:neocomplcache_force_overwrite_completefunc = 1
"     let g:neocomplcache_force_omni_patterns.c =
"                 \ '[^.[:digit:] *\t]\%(\.\|->\)'
"     let g:neocomplcache_force_omni_patterns.cpp =
"                 \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
"     let g:neocomplcache_force_omni_patterns.objc =
"                 \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
"     let g:neocomplcache_force_omni_patterns.objcpp =
"                 \ '[^.[:digit:] *\t]\%(\.\|->\)\|\h\w*::'
"     let g:neocomplcache_force_omni_patterns.java = '\k\.\k*'
"     let g:neocomplcache_force_omni_patterns.php = '[^. \t]->\h\w*\|\h\w*::'
"     let g:neocomplcache_force_omni_patterns.python =
"                 \ '\%([^. \t]\.\|^\s*@\|^\s*from\s.\+import \|^\s*from \|^\s*import \)\w*'
"
"     " For perlomni.vim setting.
"     " https://github.com/c9s/perlomni.vim
"     let g:neocomplcache_force_omni_patterns.perl = '\h\w*->\h\w*\|\h\w*::'
" endif
if

    " googlesuggest-complete-vim settings
    " setlocal completefunc=googlesuggest#Complete

" UltiSnips settings
let g:UltiSnipsExpandTrigger='<Tab>'
let g:UltiSnipsJumpForwardTrigger='<c-b>'
let g:UltiSnipsJumpBackwardTrigger='<c-z>'
let g:UltiSnipsSnippetDirectories=[ "~/.vim/bundle/vim-snippets/UltiSnips" ]

" If you want :UltiSnipsEdit to split your window.
let g:UltiSnipsEditSplit='vertical'

" vim-bufferline settings
" nnoremap gb :b<Space>

" YouCompleteMe options
let g:ycm_auto_trigger = 1
let g:ycm_key_invoke_completion = '<C-n>'
let g:ycm_key_list_select_completion = [ '<C-n>', '<Down>' ]
let g:ycm_key_list_previous_completion = [ '<C-p>', '<Up>' ]

" ScreenRestore() && ScreenSave()
let w:sourced_pre = 0

" Eclim
let g:EclimCompletionMethod = 'omnifunc'

nnoremap <localleader>pc :ProjectCreate $PWD -n java<CR>


" To enable the saving and restoring of screen positions.
let g:screen_size_restore_pos = 1

" To save and restore screen for each Vim instance.
" This is useful if you routinely run more than one Vim instance.
" For all Vim to use the same settings, change this to 0.
let g:screen_size_by_vim_instance = 0

function! ScreenFilename()
    if has('amiga')
        return 's:.vimsize'
    elseif has('win32') || has('win64')
        return g:vimPath.'/_vimsize'
    elseif has('unix')
        return g:vimPath.'/.vimsize'
    endif
endfunction

function! ScreenRestore()
    " Restore window size (columns and lines) and position
    " from values stored in vimsize file.
    " Must set font first so columns and lines are based on font size.
    if !IsI3Running()

        if !w:sourced_pre
            let w:sourced_pre = 1

            if g:screen_size_restore_pos ==# 1 && (argc() !=# 0 || has('gui_running'))
                let f = ScreenFilename()
                if g:screen_size_restore_pos && filereadable(f)
                    let vim_instance = (g:screen_size_by_vim_instance==#1?(v:servername):'VIM')
                    for line in readfile(f)
                        let sizepos = split(line)
                        if len(sizepos) ==# 5 && sizepos[0] ==# vim_instance
                            silent! execute 'set columns='.sizepos[1].' lines='.sizepos[2]
                            silent! execute 'winpos '.sizepos[3].' '.sizepos[4]
                            return
                        endif
                    endfor
                endif
            endif
        endif
    endif
endfunction

function! ScreenSave()
    if !IsI3Running()

        " Save window size and position.
        if g:screen_size_restore_pos
            let vim_instance = (g:screen_size_by_vim_instance==#1?(v:servername):'VIM')
            let data = vim_instance . ' ' . &columns . ' ' . &lines . ' ' .
                        \ (getwinposx()<0?0:getwinposx()) . ' ' .
                        \ (getwinposy()<0?0:getwinposy())
            let f = ScreenFilename()
            if filereadable(f)
                let lines = readfile(f)
                call filter(lines, "v:val !~ '^" . vim_instance . "\\>'")
                call add(lines, data)
            else
                let lines = [data]
            endif
            call writefile(lines, f)
        endif
    endif
endfunction

if !exists('g:screen_size_restore_pos')
    let g:screen_size_restore_pos = 1
endif
if !exists('g:screen_size_by_vim_instance')
    let g:screen_size_by_vim_instance = 1
endif

    " vim restore screen sizes & positions
    " autocmd VimEnter * :call ScreenRestore()
    " autocmd VimLeavePre * :call ScreenSave()
